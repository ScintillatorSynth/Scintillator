title:: VGens Overview
summary:: A list of the available VGens within Scintillator.
categories:: Quarks>Scintillator>VGens
related:: Classes/VGen, Classes/ScinthDef, Guides/Scintillator-Parallel-Classes

section::Basic Mathematical Operations

The SuperCollider UGens support a broad variety of unary, binary, and n-ary mathematical operations. These are typically expressed as operators within the link::Classes/SynthDef:: flow, and are transformed by the link::Classes/SynthDef:: programming into one of the subclasss of link::Classes/BasicOpUGen:: before being sent to the server. Scintillator implements parallel classes for unary and binary operations, with the link::Classes/BasicOpVGen:: as the base class and link::Classes/UnaryOpVGen:: and link::Classes/BinaryOpVGen:: derived classes handling a subset of the operators handled by the UGen programming.

For documentation of these operators in base SuperCollider see the link::Overviews/Operators:: overview or the link::Classes/SimpleNumber:: class documentation.

The following tables detail the current supported operations along with the ones that are not yet supported, the name of the VGen sent to the server to realize the operation, a brief explanation of their function and conceptual mathematical code. Since all numbers within a Scintillator link::Classes/ScinthDef:: must be floating-point, several of the integer operations like bit manipulation are marked as emphasis::not applicable::. If support is planned, but not yet implemented, the function is marked as emphasis::not yet implemented::.

subsection::Unary Operations

All unary operations support inputs in 1-4 dimensions, and produce outputs of the same dimension. For higher-dimensional signals all operations happen emphasis::piecewise::, meaning the operator is applied to each component of the signal independently. For example if code::b = a.neg:: and both code::a:: and code::b:: are link::Classes/Vec4:: objects then:

code::
b = Vec4.fg(
	VX.fg(a).neg,
	VY.fg(a).neg,
	VZ.fg(a).neg,
	VW.fg(a).neg);
::

table::
## strong::Operator:: || strong::VGen:: || strong::Description:: || strong::conceptual sclang code::
## code::neg:: || code::VNeg:: || Unary negation || code::x = -1 * x::
## code::reciprocal:: || code::VReciprocal:: || Reciprocal division || code::x = 1 / x::
## code::bitNot:: || emphasis::not applicable:: || Bitwise inversion || emphasis::n/a::
## code::abs:: || code::VAbs:: || Absolute value || code::if (x < 0, { x.neg }, { x })::
## code::asFloat:: || emphasis::not applicable:: || Convert to float || emphasis::n/a::
## code::asInteger:: || emphasis::not applicable:: || Convert to integer || emphasis::n/a::
## code::ceil:: || code::VCeil:: || Nearest integer greater than x || code::if ((x - x.asInteger) > 0, { (x.asInteger) + 1.0 }, { x })::
## code::floor:: || code::VFloor:: || Nearest integer lesser than x || code::x.asInteger.asFloat::
## code::frac:: || code::VFract:: || Fractional remainder of x || code::x - x.asInteger::
## code::sign:: || code::VSign:: || Sign, either -1, 0, or +1 matching sign of x || code::case { x < 0 } { -1.0 } { x == 0 } { 0.0 } { 1.0 }::
## code::squared:: || converted to code::x * x:: || Square of a number || code::x * x::
## code::cubed:: || converted to code::x * x * x:: || Cube of a number || code::x * x * x::
## code::sqrt:: || code::VSqrt:: || Square root || code::x.sqrt::
## code::exp:: || code::VExp:: || Natural exponentiation || code::e ** x::
## code::midicps:: || emphasis::not yet implemented:: || MIDI note to cycles per second || emphasis::n/a::
## code::cpsmidi:: || emphasis::not yet implemented:: || Cycles per second to MIDI note || emphasis::n/a::
## code::midiratio:: || emphasis::not yet implemented:: || Convert an interval in MIDI notes to a frequency ratio || emphasis::n/a::
## code::ratiomidi:: || emphasis::not yet implemented:: || Convert a frequency ratio to an interval in MIDI notes || emphasis::n/a::
## code::ampdb:: || emphasis::not yet implemented:: || Convert decibels to linear amplitude || emphasis::n/a::
## code::dbamp:: || emphasis::not yet implemented:: || Convert linear amplitude to decibels || emphasis::n/a::
## code::octcps:: || emphasis::not yet implemented:: || Convert decimal octaves to cycles per second || emphasis::n/a::
## code::cpsoct:: || emphasis::not yet implemented:: || Convert cycles per second to decimal octaves || emphasis::n/a::
## code::log:: || code::VLog:: || Natural logarithm || code::x.log::
## code::log2:: || code::VLog2:: || Base 2 logarithm || code::x.log2::
## code::log10:: || emphasis::not yet implemented:: || Base 10 logarithm || emphasis::n/a::
## code::sin:: || code::VSin:: || Sine || code::x.sin::
## code::cos:: || code::VCos:: || Cosine || code::x.cos::
## code::tan:: || code::VTan:: || Tangent || code::x.tan::
## code::asin:: || code::VASin:: || Arcsine || code::x.asin::
## code::acos:: || code::VACos:: || Arccosine || code::x.acos::
## code::atan:: || code::VATan:: || Arctangent || code::x.atan::
## code::rand:: || emphasis::not yet implemented:: || Returns an evenly distributed random value between zero and x || code::x.rand::
## code::rand2:: || emphasis::not yet implemented:: || Returns an evenly distributed random value beteen -x and +x || code::x.rand2::
## code::linrand:: || emphasis::not yet implemented:: || Returns a linearly distributed random value between x and zero || code::x.linrand::
## code::bilinrand:: || emphasis::not yet implemented:: || Returns a linearly distributed random value between -x and +x || code::x.bilinrand::
## code::sum3rand:: || emphasis::not yet implemented:: || Returns a value from an approximation of a Gaussian random distribution between x and zero || code::x.sum3rand::
## code::distort:: || emphasis::not yet implemented:: || Nonlinear distortion of x || emphasis::n/a::
## code::softclip:: || emphasis::not yet implemented:: || Distortion with a linear region from 0.25 to 0.75 || emphasis::n/a::
## code::coin:: || emphasis::not yet implemented:: || Returns one or zero with the probability given by the argument || code::x.coin::
## code::even:: || emphasis::not applicable:: || True if dividable by two with no remainder || emphasis::n/a::
## code::odd:: || emphasis::not applicable:: || True if dividable by two with a remainder of 1 || emphasis::n/a::
## code::rectWindow:: || emphasis::not yet implemented:: || A value for a rectangular window function between 0 and 1 || emphasis::n/a::
## code::hanWindow:: || emphasis::not yet implemented:: || A value for a Hanning window function between 0 and 1 || emphasis::n/a::
## code::welWindow:: || emphasis::not yet implemented:: || A value for a Welsh window function between 0 and 1 || emphasis::n/a::
## code::triWindow:: || emphasis::not yet implemented:: || A value for a triangle window function between 0 and 1 || emphasis::n/a::
## code::scurve:: || emphasis::not yet implemented:: || Map x on to an S-curve || emphasis::n/a::
## code::ramp:: || emphasis::not yet implemented:: || Map receiver onto a ramp starting at 0 || emphasis::n/a::
## code::isPositive:: || emphasis::not applicable:: || True if x is >= 0 || emphasis::n/a::
## code::isNegative:: || emphasis::not applicable:: || True if x is < 0 || emphasis::n/a::
## code::isStrictlyPositive:: || emphasis::not applicable:: || True if x is > 0 || emphasis::n/a::
## code::rho:: || emphasis::not yet implemented:: || The polar radius of x || emphasis::n/a::
## code::theta:: || emphasis::not yet implemented:: || The polar angle of x || emphasis::n/a::
## code::ref:: || emphasis::unknown:: || To be researched what this operator does || emphasis::??::
::

subsection::Binary Operations

Binary operations also happen emphasis::piecewise::, meaning that the binary operator is applied to each individual component separately. Conceptually if code::c = a * b:: and both code::a:: and code::b:: are link::Classes/Vec4::s then:

code::
c = Vec4.fg(
	VX.fg(a) * VX.fg(b),
	VY.fg(a) * VY.fg(b),
	VZ.fg(a) * VZ.fg(b),
	VW.fg(a) * VW.fg(b));
::

table::
## strong::Operator:: || strong::VGen:: || strong::Description:: || strong::conceptual sclang code::
## code::rotate:: || emphasis::unknown:: || To be researched what this operator does || emphasis::??::
## code::dist:: || emphasis::unknown:: || To be researched what this opreator does || emphasis::??::
## code::+:: || code::VAdd:: || Addition || code::a + b::
## code::-:: || code::VSub:: || Subtraction || code::a - b::
## code::*:: || code::VMul:: || Multiplication || code::a * b::
## code::/:: || code::VDiv:: || Division || code::a / b::
## code::div:: || code::VDiv:: || Division, TODO: validate if this is really division || code::a / b::
## code::mod:: || code::VMod:: || Floating-point modulo || code::a % b::
## code::pow:: || code::VPow:: || Exponentiation || code::a ** b::
## code::min:: || code::VMin:: || Piecewise minimum || code::if (a < b, { a }, { b });::
## code::max:: || code::VMax:: || Piecewise maximum || code::if (a > b, { a }, { b });::
## code::<:: || emphasis::not applicable:: || True if a < b || emphasis::n/a::
## code::<=:: || emphasis::not applicable:: || True if a <= b || emphasis::n/a::
## code::>:: || emphasis::not applicable:: || True if a > b || emphasis::n/a::
## code::>=:: || emphasis::not applicable:: || True if a >= b || emphasis::n/a::
## code::bitAnd:: || emphasis::not applicable:: || Bitwise logical AND || emphasis::n/a::
## code::bitOr:: || emphasis::not applicable:: || Bitwise logical OR || emphasis::n/a::
## code::bitXor:: || emphasis::not applicable:: || Bitwise logical XOR || emphasis::n/a::
## code::hammingDistance:: || emphasis::not applicable:: || Count of bits that are different || emphasis::n/a::
## code::lcm:: || emphasis::not yet implemented:: || Least common multiple || emphasis::n/a::
## code::gcd:: || emphasis::not yet implemented:: || Greates common divisor || emphasis::n/a::
## code::round:: || emphasis::not yet implemented:: || Round to a multiple of a number || emphasis::n/a::
## code::roundUp:: || emphasis::not yet implemented:: || Round up to a multiple of a number || emphasis::n/a::
## code::trunc:: || emphasis::not yet implemented:: || Truncate to a muliple of a number || emphasis::n/a::
## code::atan2:: || code::VATan2:: || Arctangent of a / b || code::(a / b).atan::
## code::hypot:: || emphasis::not yet implemented:: || Square root of the sum of the squares || emphasis::n/a::
## code::hypotApx:: || emphasis::unknown:: || To be researched what this operator does || emphasis::??::
## code::leftShift:: || emphasis::not applicable:: || Shift bits to the left || emphasis::n/a::
## code::rightShift:: || emphasis::not applicable:: || Shift bits to the right || emphasis::n/a::
## code::unsignedRightShift:: || emphasis::not applicable:: || Shift bits to the right without preserving sign bit || emphasis::n/a::
## code::ring1:: || emphasis::not yet implemented:: || Ring modulation plus first source || code::(a * b) + a::
## code::ring2:: || emphasis::not yet implemented:: || Ring modulation plus both sources || code::(a * b) + a + b::
## code::ring3:: || emphasis::not yet implemented:: || Ring modulation variant || code::a * a * b::
## code::ring4:: || emphasis::not yet implemented:: || Ring modulation variant || code::(a * a * b) - (a * b * b)::
## code::difsqr:: || emphasis::not yet implemented:: || Difference of squares || code::(a * a) - (b * b)::
## code::sumsqr:: || emphasis::not yet implemented:: || Sum of the squares || code::(a**2) + (b**2)::
## code::sqrsum:: || emphasis::not yet implemented:: || Square of the sum || code::(a + b)**2::
## code::absdif:: || emphasis::not yet implemented:: || Absolute value of the difference || code::(a - b).abs::
## code::thresh:: || emphasis::not yet implemented:: || Thresholding || code::if (a < b, { 0 }, { a });::
## code::amclip:: || emphasis::not yet implemented:: || Two quadrant multiply || code::if (b <= 0, { 0 }, { a * b });::
## code::scaleneg:: || emphasis::not yet implemented:: || Scale negative part of input || code::if (a < 0, { a * b }, { a });::
## code::clip2:: || emphasis::not yet implemented:: || Clip code::a:: to code::+/-b:: || code::if (a.abs < b, { b * a.sign }, { a });::
## code::fold2:: || emphasis::not yet implemented:: || Bilateral folding || emphasis::n/a::
## code::wrap2:: || emphasis::not yet implemented:: || Bilateral wrapping || emphasis::n/a::
## code::excesss:: || emphasis::not yet implemented:: || Residual clipping || emphasis::n/a::
## code::firstArg:: || emphasis::unknown:: || To be researched what this operator does || emphasis::??::
## code::rrand:: || emphasis::not yet implemented:: || Generate a uniformly distributed pseudorandom number in [a, b] || emphasis::n/a::
## code::exprand:: || emphasis::not yet implemented:: || Generate an exponentially distributed pseudorandom number in [a, b] || emphasis::n/a::
## code::@:: || emphasis::unknown:: || To be researched what this operator does || emphasis::??::
## code::||:: || emphasis::not applicable:: || Boolean logical OR || emphasis::n/a::
## code::&&:: || emphasis::not applicable:: || Boolean logical AND || emphasis::n/a::
## code::xor:: || emphasis::not applicable:: || Boolean logical XOR || emphasis::n/a::
## code::nand:: || emphasis::not applicable:: || Boolean logical NAND || emphasis::n/a::
::